# Note Aggregate

## Overview

The **Note** aggregate is Ventros CRM's annotation and context management system. It enables agents, the system, and automation to add rich comments, action items, and contextual information to contacts and sessions - similar to Salesforce Notes & Attachments, HubSpot Notes, Pipedrive Notes, or Zendesk Internal Comments.

A Note is a flexible annotation that captures important context, follow-up actions, internal observations, customer feedback, session summaries, and audit trail information. Notes are essential for agent collaboration, maintaining conversation context, tracking action items, and building comprehensive customer interaction history.

- **Purpose**: Context management, agent collaboration, audit trail, and action tracking
- **Location**: `internal/domain/crm/note/`
- **Entity**: `infrastructure/persistence/entities/note.go`
- **Type**: Core CRM aggregate (CRITICAL for agent workflow and customer context)

---

## Domain Model

### Aggregate Root: Note

```go
type Note struct {
    id        uuid.UUID
    contactID uuid.UUID
    sessionID *uuid.UUID  // Optional - attached to specific conversation
    tenantID  string

    // Authorship - Who created this note
    authorID   uuid.UUID
    authorType AuthorType  // agent, system, user
    authorName string

    // Content
    content  string      // Rich text content
    noteType NoteType    // general, follow_up, complaint, resolution, etc.
    priority Priority    // low, normal, high, urgent

    // Visibility & Importance
    visibleToClient bool   // Can customer see this note?
    pinned          bool   // Pinned/starred for quick access

    // Metadata
    tags        []string      // Categorization tags
    mentions    []uuid.UUID   // Mentioned agents (for notifications)
    attachments []string      // URLs to attached files

    // Timestamps
    createdAt time.Time
    updatedAt time.Time
    deletedAt *time.Time  // Soft delete

    events []DomainEvent
}
```

### Value Objects & Enums

#### 1. **AuthorType** (Value Object)
```go
type AuthorType string

const (
    AuthorTypeAgent  AuthorType = "agent"  // Created by human agent
    AuthorTypeSystem AuthorType = "system" // Auto-generated by system
    AuthorTypeUser   AuthorType = "user"   // Created by customer/user
)
```

**Purpose**: Distinguish note sources for filtering, analytics, and UI rendering.

**Use Cases**:
- **agent**: Manual notes added by support/sales agents during conversations
- **system**: Auto-generated notes (e.g., "Contact subscribed to newsletter", "Campaign enrollment completed")
- **user**: Notes created by customers themselves (feedback forms, self-service portals)

#### 2. **NoteType** (Value Object)
```go
type NoteType string

const (
    // General purpose
    NoteTypeGeneral         NoteType = "general"          // Standard annotation

    // Action tracking
    NoteTypeFollowUp        NoteType = "follow_up"        // Requires follow-up action
    NoteTypeComplaint       NoteType = "complaint"        // Customer complaint logged
    NoteTypeResolution      NoteType = "resolution"       // Issue resolution details
    NoteTypeEscalation      NoteType = "escalation"       // Escalated to manager/specialist

    // Audience
    NoteTypeInternal        NoteType = "internal"         // Internal team notes
    NoteTypeCustomer        NoteType = "customer"         // Customer-facing notes

    // Session-related
    NoteTypeSessionSummary  NoteType = "session_summary"  // Conversation summary
    NoteTypeSessionHandoff  NoteType = "session_handoff"  // Agent handoff notes
    NoteTypeSessionFeedback NoteType = "session_feedback" // Session feedback/rating

    // Marketing/Attribution
    NoteTypeAdConversion    NoteType = "ad_conversion"    // Ad conversion tracking
    NoteTypeAdCampaign      NoteType = "ad_campaign"      // Campaign attribution
    NoteTypeAdAttribution   NoteType = "ad_attribution"   // Attribution data
    NoteTypeTrackingInsight NoteType = "tracking_insight" // Tracking pixel insights
)
```

**Purpose**: Categorize notes by purpose for filtering, reporting, and workflow automation.

**Common Scenarios**:
- **follow_up**: Agent marks "Call customer tomorrow at 2 PM regarding pricing"
- **complaint**: "Customer unhappy with delivery time - 3 days late"
- **resolution**: "Issued refund of $50 and provided 20% discount code for next order"
- **escalation**: "Technical issue beyond my expertise - escalated to engineering team"
- **session_summary**: "Customer inquired about pricing, provided quote, scheduled demo"
- **session_handoff**: "Transferring to billing department - customer needs invoice correction"

#### 3. **Priority** (Value Object)
```go
type Priority string

const (
    PriorityLow    Priority = "low"     // FYI, nice-to-know
    PriorityNormal Priority = "normal"  // Standard note (default)
    PriorityHigh   Priority = "high"    // Important, requires attention
    PriorityUrgent Priority = "urgent"  // Critical, immediate action needed
)
```

**Purpose**: Task prioritization and urgency indication.

**Use Cases**:
- **low**: General observations, context notes
- **normal**: Standard notes (80% of notes)
- **high**: Important follow-ups, key decisions
- **urgent**: Critical issues, escalations, time-sensitive actions

---

## Business Invariants

### Note Invariants

1. **Content Required**: Note must have non-empty content
2. **Valid Contact**: Contact ID must be a valid, non-nil UUID
3. **Valid Author**: Author ID must be a valid, non-nil UUID
4. **Tenant Isolation**: Note belongs to exactly one tenant
5. **Session Optional**: Note can exist without session (contact-level notes)
6. **Immutable Author**: Author information cannot be changed after creation
7. **Soft Delete**: Deleted notes maintain DeletedAt timestamp for audit trail
8. **Pin Idempotency**: Pinning already pinned note does not emit duplicate events
9. **Tag Uniqueness**: Tags are simple strings (no duplicate prevention at domain level)
10. **Mention Validation**: Only non-nil UUIDs can be added to mentions

### Update Invariants

1. **Content Update**: Only content can be updated; must emit NoteUpdatedEvent
2. **Empty Content Rejection**: Cannot update note with empty content
3. **Update Tracking**: Every update changes updatedAt timestamp
4. **Delete Idempotency**: Deleting already deleted note does not emit duplicate events

---

## Events Emitted

### Note Lifecycle Events

1. **`note.added`**
   ```go
   NoteAddedEvent {
       NoteID     uuid.UUID
       ContactID  uuid.UUID
       SessionID  *uuid.UUID
       TenantID   string
       AuthorID   uuid.UUID
       AuthorType AuthorType
       AuthorName string
       Content    string
       NoteType   NoteType
       Priority   Priority
   }
   ```
   **When**: Note is created
   **Handlers**:
   - Add to contact timeline
   - Send mention notifications to agents
   - Update contact last_activity_at
   - Index for full-text search
   - Trigger webhook for external integrations

2. **`note.updated`**
   ```go
   NoteUpdatedEvent {
       NoteID     uuid.UUID
       ContactID  uuid.UUID
       TenantID   string
       UpdatedBy  uuid.UUID
       OldContent string
       NewContent string
   }
   ```
   **When**: Note content is modified
   **Handlers**:
   - Log content change for audit trail
   - Re-index for full-text search
   - Notify mentioned agents if new mentions added
   - Update contact activity timestamp

3. **`note.deleted`**
   ```go
   NoteDeletedEvent {
       NoteID    uuid.UUID
       ContactID uuid.UUID
       TenantID  string
       DeletedBy uuid.UUID
   }
   ```
   **When**: Note is soft deleted
   **Handlers**:
   - Remove from active timeline views
   - Log deletion for audit trail
   - Maintain in database (soft delete) for compliance

4. **`note.pinned`**
   ```go
   NotePinnedEvent {
       NoteID    uuid.UUID
       ContactID uuid.UUID
       TenantID  string
       PinnedBy  uuid.UUID
   }
   ```
   **When**: Note is pinned/starred by agent
   **Handlers**:
   - Move note to top of contact view
   - Update agent's pinned notes list
   - Track important notes for quick access

**Total Events**: 4 (complete lifecycle coverage)

---

## Repository Interface

### Repository Methods
```go
type Repository interface {
    // Basic CRUD
    Save(ctx context.Context, note *Note) error
    FindByID(ctx context.Context, id uuid.UUID) (*Note, error)
    Delete(ctx context.Context, id uuid.UUID) error

    // Contact & Session queries
    FindByContactID(ctx context.Context, contactID uuid.UUID, limit, offset int) ([]*Note, error)
    FindBySessionID(ctx context.Context, sessionID uuid.UUID, limit, offset int) ([]*Note, error)
    FindPinned(ctx context.Context, contactID uuid.UUID) ([]*Note, error)
    CountByContact(ctx context.Context, contactID uuid.UUID) (int, error)

    // Advanced queries
    FindByTenantWithFilters(ctx context.Context, filters NoteFilters) ([]*Note, int64, error)
    SearchByText(ctx context.Context, tenantID string, searchText string, limit int, offset int) ([]*Note, int64, error)
}
```

### NoteFilters (Query DTO)
```go
type NoteFilters struct {
    TenantID        string       // Required - tenant isolation
    ContactID       *uuid.UUID   // Optional - filter by contact
    SessionID       *uuid.UUID   // Optional - filter by session
    AuthorID        *uuid.UUID   // Optional - filter by author
    AuthorType      *string      // Optional - agent/system/user
    NoteType        *string      // Optional - note type
    Priority        *string      // Optional - priority level
    VisibleToClient *bool        // Optional - visibility filter
    Pinned          *bool        // Optional - pinned only
    CreatedAfter    *time.Time   // Optional - date range start
    CreatedBefore   *time.Time   // Optional - date range end
    Limit           int          // Pagination limit
    Offset          int          // Pagination offset
    SortBy          string       // created_at, priority
    SortOrder       string       // asc, desc
}
```

**Implementation**: `infrastructure/persistence/gorm_note_repository.go`
- Uses GORM with PostgreSQL
- Supports full-text search via ILIKE
- Soft delete via GORM's DeletedAt
- JSON serialization for mentions (UUID array)
- Defensive nil checks for optional fields

---

## Commands (NOT Implemented)

**TODO**: Create command layer for notes:

```go
// ‚ùå NOT IMPLEMENTED - Suggested commands

type AddNoteCommand struct {
    ContactID       uuid.UUID
    SessionID       *uuid.UUID
    TenantID        string
    AuthorID        uuid.UUID
    AuthorType      string
    AuthorName      string
    Content         string
    NoteType        string
    Priority        *string      // Optional, defaults to "normal"
    VisibleToClient *bool        // Optional, defaults to false
    Tags            []string     // Optional
    Mentions        []uuid.UUID  // Optional
}

type UpdateNoteContentCommand struct {
    NoteID    uuid.UUID
    UpdatedBy uuid.UUID
    Content   string
}

type PinNoteCommand struct {
    NoteID   uuid.UUID
    PinnedBy uuid.UUID
}

type UnpinNoteCommand struct {
    NoteID uuid.UUID
}

type DeleteNoteCommand struct {
    NoteID    uuid.UUID
    DeletedBy uuid.UUID
}

type AddTagToNoteCommand struct {
    NoteID uuid.UUID
    Tag    string
}

type MentionAgentCommand struct {
    NoteID  uuid.UUID
    AgentID uuid.UUID
}

type AttachFileToNoteCommand struct {
    NoteID uuid.UUID
    FileURL string
}
```

---

## Queries (‚úÖ Partially Implemented)

### ‚úÖ Implemented Queries

**Location**: `internal/application/queries/`

1. **ListNotesQuery** (`list_notes_query.go`)
   ```go
   type ListNotesQuery struct {
       TenantID        shared.TenantID
       ContactID       *uuid.UUID
       SessionID       *uuid.UUID
       AuthorID        *uuid.UUID
       AuthorType      *string
       NoteType        *string
       Priority        *string
       VisibleToClient *bool
       Pinned          *bool
       CreatedAfter    *time.Time
       CreatedBefore   *time.Time
       Page            int
       Limit           int
       SortBy          string
       SortDir         string
   }

   type ListNotesResponse struct {
       Notes      []NoteDTO
       TotalCount int64
       Page       int
       Limit      int
       TotalPages int
   }
   ```
   **Handler**: `ListNotesQueryHandler`
   **Purpose**: List notes with comprehensive filtering, pagination, and sorting

2. **SearchNotesQuery** (`search_notes_query.go`)
   ```go
   type SearchNotesQuery struct {
       TenantID   shared.TenantID
       SearchText string
       Limit      int
   }

   type SearchNotesResponse struct {
       Notes []NoteSearchResultDTO
       Count int
   }
   ```
   **Handler**: `SearchNotesQueryHandler`
   **Purpose**: Full-text search across note content and author names
   **Features**:
   - Case-insensitive ILIKE search
   - Match scoring (content: 1.5, author_name: 1.2)
   - Match field identification

### ‚ùå Suggested Additional Queries

```go
// TODO: Implement these queries

type GetNoteByIDQuery struct {
    NoteID   uuid.UUID
    TenantID shared.TenantID
}

type GetContactTimelineQuery struct {
    ContactID uuid.UUID
    TenantID  shared.TenantID
    Limit     int
    Offset    int
}
// Returns: Mixed timeline of notes, messages, activities

type GetAgentNotesQuery struct {
    AgentID   uuid.UUID
    TenantID  shared.TenantID
    StartDate time.Time
    EndDate   time.Time
}
// Returns: All notes authored by specific agent (for performance reviews)

type GetMentionedNotesQuery struct {
    AgentID  uuid.UUID
    TenantID shared.TenantID
}
// Returns: Notes where agent is mentioned (notification feed)
```

---

## Use Cases

### ‚úÖ Implemented (Query-Only)

**Location**: `internal/application/queries/`

**Current Status**: Only query handlers implemented; command handlers are MISSING.

1. **ListNotesQueryHandler** ‚úÖ
   - Comprehensive filtering by contact, session, author, type, priority, visibility, pinned status
   - Date range filtering
   - Pagination and sorting
   - Tenant isolation

2. **SearchNotesQueryHandler** ‚úÖ
   - Full-text search in content and author names
   - Match scoring and field identification
   - Tenant isolation

### ‚ùå Missing Use Cases

```go
// internal/application/crm/note/

// 1. AddNoteUseCase
//    - Validates input
//    - Creates Note aggregate via NewNote()
//    - Saves to repository
//    - Publishes note.added event
//    - Sends mention notifications to agents
//    - Returns NoteID

// 2. UpdateNoteContentUseCase
//    - Loads note
//    - Validates permissions (updater = author or admin)
//    - Updates content via Note.UpdateContent()
//    - Saves note
//    - Publishes note.updated event

// 3. PinNoteUseCase
//    - Loads note
//    - Validates permissions (tenant match)
//    - Pins note via Note.Pin()
//    - Saves note
//    - Publishes note.pinned event

// 4. DeleteNoteUseCase
//    - Loads note
//    - Validates permissions (deleter = author or admin)
//    - Soft deletes via Note.Delete()
//    - Saves note
//    - Publishes note.deleted event

// 5. AddSessionNoteUseCase
//    - Creates note
//    - Attaches to session via Note.AttachToSession()
//    - Validates session exists and belongs to contact
//    - Saves note
//    - Updates session's notes_count

// 6. MentionAgentUseCase
//    - Loads note
//    - Mentions agent via Note.MentionAgent()
//    - Saves note
//    - Sends notification to mentioned agent
//    - Creates "You were mentioned" event

// 7. GenerateSessionSummaryUseCase (AI-powered)
//    - Loads session messages
//    - Generates summary via AI/LLM
//    - Creates note with type=session_summary
//    - Attaches to session
//    - Saves note
```

---

## HTTP API

### ‚úÖ Implemented Endpoints

**Location**: `infrastructure/http/handlers/note_handler.go`

```yaml
# Query endpoints (implemented)
GET    /api/v1/crm/notes/advanced    # List notes with filters (ListNotesAdvanced)
GET    /api/v1/crm/notes/search      # Search notes by text (SearchNotes)
```

### ‚ùå Missing Endpoints

```yaml
# CRUD operations (NOT IMPLEMENTED)
POST   /api/v1/crm/notes                    # Create note
GET    /api/v1/crm/notes/:id                # Get note by ID
PUT    /api/v1/crm/notes/:id/content        # Update note content
DELETE /api/v1/crm/notes/:id                # Delete note (soft)

# Note actions (NOT IMPLEMENTED)
POST   /api/v1/crm/notes/:id/pin            # Pin note
DELETE /api/v1/crm/notes/:id/pin            # Unpin note
POST   /api/v1/crm/notes/:id/tags           # Add tag
DELETE /api/v1/crm/notes/:id/tags/:tag      # Remove tag
POST   /api/v1/crm/notes/:id/mentions       # Mention agent
POST   /api/v1/crm/notes/:id/attachments    # Add attachment

# Aggregate queries (NOT IMPLEMENTED)
GET    /api/v1/crm/contacts/:id/notes       # Get contact's notes
GET    /api/v1/crm/sessions/:id/notes       # Get session's notes
GET    /api/v1/crm/contacts/:id/notes/pinned # Get pinned notes for contact

# Analytics (NOT IMPLEMENTED)
GET    /api/v1/crm/notes/stats              # Note statistics by type/priority
GET    /api/v1/crm/agents/:id/notes         # Agent's note activity
GET    /api/v1/crm/notes/mentions           # My mentions (notification feed)
```

**Implementation Status**: ‚ö†Ô∏è INCOMPLETE (only 2 query endpoints implemented)

---

## Real-World Usage Patterns

### Pattern 1: Agent Call Notes

```go
// During support call, agent adds notes
note1, _ := note.NewNote(
    contactID,
    "tenant-123",
    agentID,
    note.AuthorTypeAgent,
    "Sarah Johnson",
    "Customer called regarding order #12345. Reports that package arrived damaged. Customer photos show crushed box and broken item. Apologized and offered refund or replacement.",
    note.NoteTypeComplaint,
)
note1.AttachToSession(sessionID)
note1.SetPriority(note.PriorityHigh)
note1.AddTag("damaged-shipment")
note1.AddTag("refund-requested")
note1.MentionAgent(shippingManagerID) // Notify shipping manager

// Follow-up action note
note2, _ := note.NewNote(
    contactID,
    "tenant-123",
    agentID,
    note.AuthorTypeAgent,
    "Sarah Johnson",
    "Follow-up required: Call customer tomorrow (2025-10-13 at 2 PM) to confirm refund was received. Promised 20% discount code for next order.",
    note.NoteTypeFollowUp,
)
note2.SetPriority(note.PriorityUrgent)
note2.AddTag("callback-scheduled")
```

### Pattern 2: System-Generated Notes

```go
// Automation creates notes for tracking
note, _ := note.NewNote(
    contactID,
    "tenant-123",
    systemUserID,
    note.AuthorTypeSystem,
    "Automation Engine",
    "Contact enrolled in 'Welcome Series' campaign. First email scheduled for 2025-10-13 at 9:00 AM.",
    note.NoteTypeGeneral,
)
note.SetPriority(note.PriorityLow)
note.AddTag("automation")
note.AddTag("campaign-enrollment")

// Ad conversion tracking
conversionNote, _ := note.NewNote(
    contactID,
    "tenant-123",
    systemUserID,
    note.AuthorTypeSystem,
    "Tracking Pixel",
    "Ad conversion tracked: Google Ads campaign 'Q4-Promo', UTM source: google, medium: cpc, campaign: q4-promo-2025",
    note.NoteTypeAdConversion,
)
conversionNote.AddTag("google-ads")
conversionNote.AddTag("paid-acquisition")
```

### Pattern 3: Session Handoff

```go
// Agent transfers chat to specialist
handoffNote, _ := note.NewNote(
    contactID,
    "tenant-123",
    agentID,
    note.AuthorTypeAgent,
    "Mike Chen",
    "Transferring to billing specialist. Customer needs invoice correction for order #98765. Original invoice shows $299.99, but promo code SAVE20 was not applied. Correct amount should be $239.99.",
    note.NoteTypeSessionHandoff,
)
handoffNote.AttachToSession(sessionID)
handoffNote.SetPriority(note.PriorityHigh)
handoffNote.MentionAgent(billingSpecialistID)
handoffNote.AddTag("billing-issue")
handoffNote.AddTag("invoice-correction")
handoffNote.SetVisibility(false) // Internal only
```

### Pattern 4: AI Session Summary

```go
// AI generates session summary after conversation ends
summaryNote, _ := note.NewNote(
    contactID,
    "tenant-123",
    aiUserID,
    note.AuthorTypeSystem,
    "AI Assistant",
    `Session Summary:
- Customer inquired about Enterprise plan pricing
- Discussed features: SSO, custom integrations, dedicated support
- Provided quote: $2,999/month for 50 users
- Customer expressed interest but needs to discuss with team
- Next steps: Send formal proposal via email, follow up in 3 days
- Overall sentiment: Positive, high purchase intent`,
    note.NoteTypeSessionSummary,
)
summaryNote.AttachToSession(sessionID)
summaryNote.SetPriority(note.PriorityNormal)
summaryNote.SetVisibility(false)
summaryNote.AddTag("sales-opportunity")
summaryNote.AddTag("enterprise-plan")
```

### Pattern 5: Escalation Note

```go
// Agent escalates technical issue
escalationNote, _ := note.NewNote(
    contactID,
    "tenant-123",
    agentID,
    note.AuthorTypeAgent,
    "Alex Rodriguez",
    "ESCALATION: Customer reports API integration failing with 500 errors. Issue started 2 hours ago. Customer is on Enterprise plan with SLA. This is blocking their production deployment. Need engineering team to investigate immediately.",
    note.NoteTypeEscalation,
)
escalationNote.SetPriority(note.PriorityUrgent)
escalationNote.MentionAgent(engineeringLeadID)
escalationNote.MentionAgent(customerSuccessManagerID)
escalationNote.Pin(agentID) // Pin for visibility
escalationNote.AddTag("sla-critical")
escalationNote.AddTag("api-issue")
escalationNote.AddTag("production-down")
```

### Pattern 6: Customer-Visible Note

```go
// Public note visible to customer
publicNote, _ := note.NewNote(
    contactID,
    "tenant-123",
    agentID,
    note.AuthorTypeAgent,
    "Support Team",
    "We've reviewed your account and applied a $50 credit for the inconvenience caused by the delayed shipment. The credit will appear on your account within 24 hours and can be used on your next purchase. Thank you for your patience!",
    note.NoteTypeResolution,
)
publicNote.SetVisibility(true) // Customer can see this
publicNote.SetPriority(note.PriorityNormal)
publicNote.AddTag("customer-credit")
publicNote.AddTag("resolution")
```

---

## Performance Considerations

### Scalability

- **Contact Notes**: Average 10-50 notes per contact
- **High-Activity Contacts**: Up to 500+ notes for long-term customers
- **Session Notes**: Typically 1-5 notes per session
- **Search Performance**: Sub-second full-text search with proper indexes
- **Write Load**: ~1000 notes/minute under normal load

### Database Indexes

**Existing Indexes** (from migration and entity definition):
```sql
-- Primary key
CREATE UNIQUE INDEX ON notes(id);

-- Contact queries (most common)
CREATE INDEX idx_notes_contact ON notes(contact_id);
CREATE INDEX idx_notes_tenant_contact ON notes(tenant_id, contact_id);

-- Session queries
CREATE INDEX idx_notes_session ON notes(session_id);

-- Filtering indexes
CREATE INDEX idx_notes_tenant ON notes(tenant_id);
CREATE INDEX idx_notes_author ON notes(author_id);
CREATE INDEX idx_notes_author_type ON notes(author_type);
CREATE INDEX idx_notes_type ON notes(note_type);
CREATE INDEX idx_notes_tenant_type ON notes(tenant_id, note_type);
CREATE INDEX idx_notes_priority ON notes(priority);
CREATE INDEX idx_notes_tenant_priority ON notes(tenant_id, priority);
CREATE INDEX idx_notes_visible ON notes(visible_to_client);
CREATE INDEX idx_notes_pinned ON notes(pinned);

-- Timestamp queries
CREATE INDEX idx_notes_created ON notes(created_at);
CREATE INDEX idx_notes_updated ON notes(updated_at);
CREATE INDEX idx_notes_deleted ON notes(deleted_at);

-- Full-text search (PostgreSQL GIN indexes)
CREATE INDEX idx_notes_tags ON notes USING gin(tags);
CREATE INDEX idx_notes_mentions ON notes USING gin(mentions);
```

### Optimizations

1. **Pinned Notes Cache**: Cache pinned notes in Redis for instant access
2. **Session Summary Pre-generation**: Generate AI summaries in background
3. **Mention Notifications**: Batch notifications every 5 minutes
4. **Full-Text Search**: Use PostgreSQL text search vectors for better performance
5. **Archival Strategy**: Archive notes older than 2 years to separate table
6. **Pagination**: Always use limit/offset for large result sets
7. **Contact Timeline**: Cache recent 20 notes per contact

### Query Performance Tips

```go
// ‚úÖ GOOD: Query with specific contact and limit
notes, _ := noteRepo.FindByContactID(ctx, contactID, 20, 0)

// ‚úÖ GOOD: Query pinned notes only (indexed)
pinnedNotes, _ := noteRepo.FindPinned(ctx, contactID)

// ‚úÖ GOOD: Search with reasonable limit
results, _ := noteRepo.SearchByText(ctx, tenantID, "urgent", 50, 0)

// ‚ùå BAD: Query without limit (returns all notes)
// notes, _ := noteRepo.FindByContactID(ctx, contactID, -1, 0)

// ‚ùå BAD: Search without limit (can timeout)
// results, _ := noteRepo.SearchByText(ctx, tenantID, "a", -1, 0)
```

---

## Testing Checklist

### Unit Tests (Domain Layer) ‚úÖ COMPLETE

**Location**: `internal/domain/crm/note/note_test.go`

- [x] Note creation with valid data
- [x] Validation errors (empty content, invalid contact, invalid author)
- [x] Different author types (agent, system, user)
- [x] Different note types (14 types tested)
- [x] ReconstructNote with all fields
- [x] Attach to session
- [x] Update content (success and validation)
- [x] Set priority (all 4 levels)
- [x] Set visibility (true/false)
- [x] Pin/unpin note
- [x] Pin idempotency (no duplicate events)
- [x] Add/remove tags
- [x] Mention agents
- [x] Add attachments
- [x] Delete note (soft delete)
- [x] Delete idempotency
- [x] Domain events emission (4 events)
- [x] Event management (clear, immutable copies)
- [x] Getter copies (defensive)
- [x] Constants validation

**Status**: ‚úÖ **100% coverage** (436 lines of comprehensive tests)

### Integration Tests (Repository Layer) ‚ùå TODO

**Location**: `infrastructure/persistence/gorm_note_repository_test.go` (NOT FOUND)

- [ ] Save note (create)
- [ ] Save note (update)
- [ ] FindByID (found and not found)
- [ ] FindByContactID with pagination
- [ ] FindByContactID ordering (pinned first, then created_at DESC)
- [ ] FindBySessionID with pagination
- [ ] FindPinned for contact
- [ ] CountByContact
- [ ] Delete (soft delete)
- [ ] FindByTenantWithFilters (all filter combinations)
- [ ] SearchByText (content match)
- [ ] SearchByText (author name match)
- [ ] SearchByText pagination
- [ ] Entity-to-domain conversion (mentions JSON deserialization)
- [ ] Domain-to-entity conversion (mentions JSON serialization)
- [ ] Nil collections handling
- [ ] DeletedAt handling

### End-to-End Tests (Application Layer) ‚ùå TODO

- [ ] AddNote ‚Üí Save ‚Üí Event published ‚Üí Notification sent
- [ ] UpdateNoteContent ‚Üí Audit trail logged
- [ ] DeleteNote ‚Üí Soft delete ‚Üí Removed from active views
- [ ] PinNote ‚Üí Appears at top of contact view
- [ ] ListNotes with complex filters
- [ ] SearchNotes with various queries
- [ ] GetContactTimeline (mixed notes + messages)
- [ ] MentionAgent ‚Üí Notification delivered
- [ ] AttachToSession ‚Üí Note appears in session view

### API Tests (HTTP Layer) ‚ö†Ô∏è PARTIAL

- [x] GET /api/v1/crm/notes/advanced (implemented)
- [x] GET /api/v1/crm/notes/search (implemented)
- [ ] POST /api/v1/crm/notes (NOT IMPLEMENTED)
- [ ] PUT /api/v1/crm/notes/:id/content (NOT IMPLEMENTED)
- [ ] DELETE /api/v1/crm/notes/:id (NOT IMPLEMENTED)
- [ ] POST /api/v1/crm/notes/:id/pin (NOT IMPLEMENTED)

---

## Suggested Improvements

### 1. Rich Text Editor Support

```go
type NoteContent struct {
    PlainText string                   `json:"plain_text"` // For search
    HTML      string                   `json:"html"`       // Rich formatting
    Markdown  string                   `json:"markdown"`   // Alternative format
    Format    string                   `json:"format"`     // "plain" | "html" | "markdown"
}

// Update Note aggregate
type Note struct {
    // ... existing fields
    contentFormat string      // "plain", "html", "markdown"
    contentData   NoteContent // Structured content
}
```

### 2. Note Templates

```go
type NoteTemplate struct {
    ID          uuid.UUID
    TenantID    string
    Name        string
    Description string
    NoteType    NoteType
    Priority    Priority
    Content     string   // Template with {{placeholders}}
    Tags        []string
}

// Usage: "Quick follow-up", "Escalation template", "Resolution template"
```

### 3. Note Reactions (Slack-style)

```go
type NoteReaction struct {
    Emoji     string    // üëç, ‚ù§Ô∏è, ‚úÖ
    AgentID   uuid.UUID
    AgentName string
    AddedAt   time.Time
}

// Add to Note aggregate
type Note struct {
    // ... existing fields
    reactions []NoteReaction
}

func (n *Note) AddReaction(emoji string, agentID uuid.UUID, agentName string)
func (n *Note) RemoveReaction(emoji string, agentID uuid.UUID)
```

### 4. Note Threads (Comments on Notes)

```go
type NoteComment struct {
    ID        uuid.UUID
    NoteID    uuid.UUID
    AuthorID  uuid.UUID
    Content   string
    CreatedAt time.Time
}

// Enable discussion threads on important notes
```

### 5. Smart Mentions with Context

```go
type Mention struct {
    AgentID   uuid.UUID
    AgentName string
    Reason    string // "needs-approval", "fyi", "action-required"
    Priority  Priority
}

// More contextual mentions for better notifications
```

### 6. AI-Powered Suggestions

```go
type AISuggestion struct {
    SuggestedType     NoteType
    SuggestedPriority Priority
    SuggestedTags     []string
    SuggestedMentions []uuid.UUID
    Confidence        float64
}

// AI suggests note type, priority, tags based on content
```

### 7. Note Analytics

```go
type NoteAnalytics struct {
    TotalNotes          int
    NotesByType         map[NoteType]int
    NotesByPriority     map[Priority]int
    NotesByAuthorType   map[AuthorType]int
    AverageNotesPerDay  float64
    TopTags             []string
    MostActiveAgents    []AgentActivity
}
```

### 8. Bulk Operations

```go
type BulkPinNotesCommand struct {
    NoteIDs []uuid.UUID
}

type BulkTagNotesCommand struct {
    NoteIDs []uuid.UUID
    Tags    []string
}

type BulkDeleteNotesCommand struct {
    NoteIDs []uuid.UUID
}
```

### 9. Note Versioning (Audit Trail)

```go
type NoteVersion struct {
    Version   int
    Content   string
    UpdatedBy uuid.UUID
    UpdatedAt time.Time
}

// Track all content changes for compliance
```

### 10. Export & Reporting

```go
type ExportNotesCommand struct {
    ContactID *uuid.UUID
    DateRange DateRange
    Format    string // "pdf", "csv", "json"
}

// Export contact history for legal/compliance
```

---

## Related Aggregates

- **Contact**: Notes are attached to contacts (primary relationship)
- **Session**: Notes can be attached to sessions (optional)
- **Agent**: Agents author notes, can be mentioned
- **Message**: Notes complement message history in contact timeline
- **Tag**: Tags applied to notes (value object, not aggregate)
- **User**: Users can create notes (customer feedback)

---

## Industry Comparison

| Feature | Ventros CRM | Salesforce | HubSpot | Zendesk | Pipedrive |
|---------|-------------|------------|---------|---------|-----------|
| Rich text notes | ‚ùå (plain) | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Note types | ‚úÖ (14) | ‚ùå | ‚ùå | ‚úÖ (2) | ‚ùå |
| Priority levels | ‚úÖ (4) | ‚ùå | ‚ùå | ‚ùå | ‚ùå |
| Agent mentions | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
| Attachments | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Pin/star notes | ‚úÖ | ‚ùå | ‚úÖ | ‚ùå | ‚úÖ |
| Tags | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Full-text search | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Client visibility | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ | ‚ùå |
| Note templates | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Note threads | ‚ùå | ‚ùå | ‚ùå | ‚úÖ | ‚ùå |
| AI summaries | ‚ùå | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå |
| Audit trail | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |

**Ventros Strengths**:
- Comprehensive note type system (14 types vs competitors' 0-2)
- Priority-based organization (unique feature)
- Clean DDD architecture
- Author type distinction (agent/system/user)
- Session attachment (conversation context)
- Client visibility toggle

**Suggested Additions**:
- Rich text editor support
- Note templates
- AI-powered summaries and suggestions
- Note threads/comments
- Better attachment management
- Bulk operations

---

## Migration & Schema

**Location**: `infrastructure/database/migrations/000001_initial_schema.up.sql`

```sql
CREATE TABLE public.notes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    contact_id uuid NOT NULL,
    session_id uuid,
    tenant_id text NOT NULL,

    -- Authorship
    author_id uuid NOT NULL,
    author_type text NOT NULL,
    author_name text NOT NULL,

    -- Content
    content text NOT NULL,
    note_type text NOT NULL,
    priority text DEFAULT 'normal'::text NOT NULL,

    -- Visibility
    visible_to_client boolean DEFAULT false,
    pinned boolean DEFAULT false,

    -- Metadata
    tags text[],
    mentions jsonb,
    attachments text[],

    -- Timestamps
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone
);

-- Primary key
ALTER TABLE ONLY public.notes
    ADD CONSTRAINT notes_pkey PRIMARY KEY (id);

-- Foreign keys
ALTER TABLE ONLY public.notes
    ADD CONSTRAINT notes_contact_id_fkey
    FOREIGN KEY (contact_id) REFERENCES public.contacts(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.notes
    ADD CONSTRAINT notes_session_id_fkey
    FOREIGN KEY (session_id) REFERENCES public.sessions(id) ON DELETE CASCADE;
```

**Key Design Decisions**:
1. **UUID Primary Key**: Distributed ID generation
2. **JSONB for Mentions**: Flexible UUID array storage
3. **TEXT[] for Tags/Attachments**: Native PostgreSQL array type
4. **Soft Delete**: DeletedAt for audit trail
5. **Cascade Deletes**: Automatic cleanup when contact/session deleted
6. **No Version Field**: Notes don't need optimistic locking (single-author updates)

---

## Documentation References

- **Domain Events**: `internal/domain/crm/note/events.go`
- **Repository Interface**: `internal/domain/crm/note/repository.go`
- **Domain Model**: `internal/domain/crm/note/note.go`
- **Unit Tests**: `internal/domain/crm/note/note_test.go`
- **Repository Implementation**: `infrastructure/persistence/gorm_note_repository.go`
- **Entity**: `infrastructure/persistence/entities/note.go`
- **HTTP Handler**: `infrastructure/http/handlers/note_handler.go`
- **Query Handlers**:
  - `internal/application/queries/list_notes_query.go`
  - `internal/application/queries/search_notes_query.go`
- **Migration**: `infrastructure/database/migrations/000001_initial_schema.up.sql`

---

## Common Questions & Answers

### Q: Why so many note types (14)?
**A**: Different note purposes require different handling, filtering, and UI rendering. For example, `session_handoff` notes need special visibility in transfer workflows, while `ad_conversion` notes feed into attribution reporting. This granularity enables powerful filtering and analytics.

### Q: Why separate `visibleToClient` field instead of using `noteType`?
**A**: A note can be of type `resolution` (categorization) but still be internal-only. Visibility is an orthogonal concern to note type.

### Q: Why store mentions as JSONB instead of separate table?
**A**: Mentions are simple UUID arrays that are always loaded with the note. JSONB avoids JOIN overhead and is simpler for this use case. If we need complex mention queries (e.g., "all notes mentioning agent X"), we can query the JSONB column with GIN index.

### Q: Why no note templates in domain model?
**A**: Templates are a UI/convenience feature, not core domain logic. They can be implemented at the application layer or as a separate aggregate if needed.

### Q: How to prevent note spam/abuse?
**A**: Implement rate limiting at application layer (e.g., max 10 notes per minute per agent). Domain model remains focused on business rules.

### Q: What happens to notes when contact is deleted?
**A**: Cascade delete removes all notes (see foreign key constraint). For compliance, consider archiving notes before contact deletion.

### Q: How to implement "mention notifications"?
**A**: Listen to `note.added` and `note.updated` events. If mentions array has values, create notification records for mentioned agents. (TODO: Implement NotificationService)

---

**Last Updated**: 2025-10-12
**Status**: ‚úÖ Domain Complete, ‚ö†Ô∏è Application Incomplete (only queries), ‚ùå Commands Missing
**Priority**: HIGH (Critical for agent workflow)
**Estimated Completion**: 1 week (command handlers + missing API endpoints + integration tests)
